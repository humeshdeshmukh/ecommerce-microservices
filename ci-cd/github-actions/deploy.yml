# deploy.yml - GitHub Actions workflow (CI + CD)
# - Builds & pushes images to Docker registry (DockerHub or ECR)
# - Deploys to Kubernetes using a KUBECONFIG secret (base64)
# Secrets required in GitHub repo settings:
# - REGISTRY (eg docker.io/username or ECR URL)
# - REGISTRY_USERNAME
# - REGISTRY_PASSWORD
# - KUBE_CONFIG_DATA (base64 kubeconfig)
# - OPTIONAL: AWS credentials if using ECR
#
name: CI-CD Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  SERVICES: auth-service product-service order-service cart-service payment-service notification-service api-gateway
  IMAGE_TAG: ${{ github.sha }}   # short SHA tag is used for immutability

jobs:
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build & push images (all services)
        # Uses a shell loop to build/push each service image
        run: |
          set -e
          for svc in $SERVICES; do
            if [ -f services/$svc/Dockerfile ]; then
              IMAGE="${{ secrets.REGISTRY }}/${svc}:${IMAGE_TAG}"
              echo "Building $IMAGE"
              docker build -t "$IMAGE" services/$svc
              echo "Pushing $IMAGE"
              docker push "$IMAGE"
            else
              echo "No Dockerfile for services/$svc - skipping"
            fi
          done

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Decode Kubeconfig
        run: |
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 --decode > kubeconfig
          chmod 600 kubeconfig
        shell: bash

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Set KUBECONFIG env var
        run: echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      - name: Update manifests with new image tags
        run: |
          set -e
          REGISTRY=${{ secrets.REGISTRY }}
          TAG=${IMAGE_TAG}
          for svc in $SERVICES; do
            if [ -f infra/kubernetes/${svc}-deployment.yaml ]; then
              IMAGE="${REGISTRY}/${svc}:${TAG}"
              # Replace placeholders like IMAGE_AUTH-SERVICE in the YAMLs or update image lines
              sed -i "s|IMAGE_${svc^^}|${IMAGE}|g" infra/kubernetes/*.yaml || true
              sed -i -E "s|(image:\\s*).*${svc}(:[a-zA-Z0-9._-]*)?\\b|\\1${IMAGE}|g" infra/kubernetes/*.yaml || true
            fi
          done

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f infra/kubernetes/namespace.yaml || true
          kubectl apply -f infra/kubernetes/configmaps.yaml || true
          kubectl apply -f infra/kubernetes/secrets.yaml || true
          kubectl apply -R -f infra/kubernetes/
        env:
          KUBECONFIG: ${{ github.workspace }}/kubeconfig

      - name: Wait for rollout (basic)
        run: |
          KUBECONFIG=$PWD/kubeconfig
          for svc in $SERVICES; do
            kubectl -n default rollout status deploy/$svc --timeout=90s || echo "rollout timed out for $svc"
          done

      - name: Cleanup kubeconfig
        run: rm -f kubeconfig
